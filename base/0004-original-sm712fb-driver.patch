From d9040c1564a89c74697b160ced8009dd0bb36199 Mon Sep 17 00:00:00 2001
From: Icenowy <icenowy@outlook.com>
Date: Mon, 13 Jul 2015 14:08:28 +0800
Subject: original sm712fb patched

Signed-off-by: Icenowy <icenowy@outlook.com>
---
 drivers/video/fbdev/Kconfig                  |   13 +
 drivers/video/fbdev/Makefile                 |    1 +
 drivers/video/fbdev/sm712fb/Makefile         |    3 +
 drivers/video/fbdev/sm712fb/TODO             |    7 +
 drivers/video/fbdev/sm712fb/sm712fb_accel.c  |  246 +++++++
 drivers/video/fbdev/sm712fb/sm712fb_accel.h  |   33 +
 drivers/video/fbdev/sm712fb/sm712fb_drv.c    | 1022 ++++++++++++++++++++++++++
 drivers/video/fbdev/sm712fb/sm712fb_drv.h    |  130 ++++
 drivers/video/fbdev/sm712fb/sm712fb_io.h     |   90 +++
 drivers/video/fbdev/sm712fb/sm712fb_modedb.h |  682 +++++++++++++++++
 10 files changed, 2227 insertions(+)
 create mode 100644 drivers/video/fbdev/sm712fb/Makefile
 create mode 100644 drivers/video/fbdev/sm712fb/TODO
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_accel.c
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_accel.h
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_drv.c
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_drv.h
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_io.h
 create mode 100644 drivers/video/fbdev/sm712fb/sm712fb_modedb.h

diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 1094623..46d63c1 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2450,6 +2450,19 @@ config FB_SIMPLE
 	  Configuration re: surface address, size, and format must be provided
 	  through device tree, or plain old platform data.
 
+config FB_SM712
+	tristate "Silicon Motion SM712 framebuffer support"
+	depends on FB && PCI
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Frame buffer driver for the Silicon Motion SM712 chip.
+
+	  This driver is also available as a module. The module will be
+	  called sm712fb. If you want to compile it as a module, say M
+	  here and read <file:Documentation/kbuild/modules.txt>.
+
 source "drivers/video/fbdev/omap/Kconfig"
 source "drivers/video/fbdev/omap2/Kconfig"
 source "drivers/video/fbdev/exynos/Kconfig"
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 1979aff..9b694f9 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -114,6 +114,7 @@ obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
 obj-$(CONFIG_FB_PS3)		  += ps3fb.o
 obj-$(CONFIG_FB_SM501)            += sm501fb.o
+obj-$(CONFIG_FB_SM712)		  += sm712fb/
 obj-$(CONFIG_FB_UDL)		  += udlfb.o
 obj-$(CONFIG_FB_SMSCUFX)	  += smscufx.o
 obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
diff --git a/drivers/video/fbdev/sm712fb/Makefile b/drivers/video/fbdev/sm712fb/Makefile
new file mode 100644
index 0000000..9bf3519
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FB_SM712) += sm712fb.o
+
+sm712fb-objs := sm712fb_drv.o sm712fb_accel.o
diff --git a/drivers/video/fbdev/sm712fb/TODO b/drivers/video/fbdev/sm712fb/TODO
new file mode 100644
index 0000000..dcfd4e7
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/TODO
@@ -0,0 +1,7 @@
+TODO:
+- Dual head support
+- refine the code, convert more registers magic numbers to macros
+- Does it really works on Big Endian machines?
+
+Please send any patches to Greg Kroah-Hartman <greg@kroah.com> and
+Tom Li <biergaizi@member.fsf.org>.
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_accel.c b/drivers/video/fbdev/sm712fb/sm712fb_accel.c
new file mode 100644
index 0000000..12fce1f
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_accel.c
@@ -0,0 +1,246 @@
+/*
+ * Silicon Motion SM712 frame buffer device
+ *
+ * Copyright (C) 2006 Silicon Motion Technology Corp.
+ * Authors:  Ge Wang, gewang@siliconmotion.com
+ *	     Boyod boyod.yang@siliconmotion.com.cn
+ *
+ * Copyright (C) 2009 Lemote, Inc.
+ * Author:   Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * Copyright (C) 2011 Igalia, S.L.
+ * Author:   Javier M. Mellid <jmunhoz@igalia.com>
+ *
+ * Copyright (C) 2014 Tom Li.
+ * Author:   Tom Li (Yifeng Li) <biergaizi@member.fsf.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ * Framebuffer driver for Silicon Motion SM712 chip
+ */
+
+#include <linux/fb.h>
+#include <linux/screen_info.h>
+#include <linux/delay.h>
+
+#include "sm712fb_drv.h"
+#include "sm712fb_accel.h"
+
+static inline u32 bytes_to_dword(const u8 *bytes, int length)
+{
+	u32 dword = 0;
+
+	switch (length) {
+	case 4:
+#ifdef __BIG_ENDIAN
+		dword += bytes[3];
+#else
+		dword += bytes[3] << 24;
+#endif
+	case 3:
+#ifdef __BIG_ENDIAN
+		dword += bytes[2] << 8;
+#else
+		dword += bytes[2] << 16;
+#endif
+	case 2:
+#ifdef __BIG_ENDIAN
+		dword += bytes[1] << 16;
+#else
+		dword += bytes[1] << 8;
+#endif
+	case 1:
+#ifdef __BIG_ENDIAN
+		dword += bytes[0] << 24;
+#else
+		dword += bytes[0];
+#endif
+	}
+	return dword;
+}
+
+int sm712fb_init_accel(struct sm712fb_info *fb)
+{
+	u8 reg;
+
+	/* reset the 2D engine */
+	sm712_write_seq(fb, 0x21, sm712_read_seq(fb, 0x21) & 0xf8);
+	reg = sm712_read_seq(fb, 0x15);
+	sm712_write_seq(fb, 0x15, reg | 0x30);
+	sm712_write_seq(fb, 0x15, reg);
+
+	if (sm712fb_wait(fb) != 0)
+		return -1;
+
+	sm712_write_dpr(fb, DPR_CROP_TOPLEFT_COORDS, DPR_COORDS(0, 0));
+
+	/* same width for DPR_PITCH and DPR_SRC_WINDOW */
+	sm712_write_dpr(fb, DPR_PITCH,
+			DPR_COORDS(fb->fb.var.xres, fb->fb.var.xres));
+	sm712_write_dpr(fb, DPR_SRC_WINDOW,
+			DPR_COORDS(fb->fb.var.xres, fb->fb.var.xres));
+
+	sm712_write_dpr(fb, DPR_BYTE_BIT_MASK, 0xffffffff);
+	sm712_write_dpr(fb, DPR_COLOR_COMPARE_MASK, 0);
+	sm712_write_dpr(fb, DPR_COLOR_COMPARE, 0);
+	sm712_write_dpr(fb, DPR_SRC_BASE, 0);
+	sm712_write_dpr(fb, DPR_DST_BASE, 0);
+	sm712_read_dpr(fb, DPR_DST_BASE);
+
+	return 0;
+}
+
+int sm712fb_wait(struct sm712fb_info *fb)
+{
+	int i;
+	u8 reg;
+
+	for (i = 0; i < 10000; i++) {
+		reg = sm712_read_seq(fb, SCR_DE_STATUS);
+		if ((reg & SCR_DE_STATUS_MASK) == SCR_DE_ENGINE_IDLE)
+			return 0;
+		udelay(1);
+	}
+	return -EBUSY;
+}
+
+void sm712fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)
+{
+	u32 width = rect->width, height = rect->height;
+	u32 dx = rect->dx, dy = rect->dy;
+	u32 color;
+
+	struct sm712fb_info *sfb = info->par;
+
+	if (unlikely(info->state != FBINFO_STATE_RUNNING))
+		return;
+	if ((rect->dx >= info->var.xres_virtual) ||
+	    (rect->dy >= info->var.yres_virtual))
+		return;
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR ||
+	    info->fix.visual == FB_VISUAL_DIRECTCOLOR)
+		color = ((u32 *) (info->pseudo_palette))[rect->color];
+	else
+		color = rect->color;
+
+	sm712_write_dpr(sfb, DPR_FG_COLOR, color);
+	sm712_write_dpr(sfb, DPR_DST_COORDS, DPR_COORDS(dx, dy));
+	sm712_write_dpr(sfb, DPR_SPAN_COORDS, DPR_COORDS(width, height));
+	sm712_write_dpr(sfb, DPR_DE_CTRL, DE_CTRL_START | DE_CTRL_ROP_ENABLE |
+			(DE_CTRL_COMMAND_SOLIDFILL << DE_CTRL_COMMAND_SHIFT) |
+			(DE_CTRL_ROP_SRC << DE_CTRL_ROP_SHIFT));
+	sm712_read_dpr(sfb, DPR_DE_CTRL);
+	sm712fb_wait(sfb);
+}
+
+void sm712fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)
+{
+	u32 sx = area->sx, sy = area->sy;
+	u32 dx = area->dx, dy = area->dy;
+	u32 height = area->height, width = area->width;
+	u32 direction;
+
+	struct sm712fb_info *sfb = info->par;
+
+	if (unlikely(info->state != FBINFO_STATE_RUNNING))
+		return;
+	if ((sx >= info->var.xres_virtual) || (sy >= info->var.yres_virtual))
+		return;
+
+	if (sy < dy || (sy == dy && sx <= dx)) {
+		sx += width - 1;
+		dx += width - 1;
+		sy += height - 1;
+		dy += height - 1;
+		direction = DE_CTRL_RTOL;
+	} else
+		direction = 0;
+
+	sm712_write_dpr(sfb, DPR_SRC_COORDS, DPR_COORDS(sx, sy));
+	sm712_write_dpr(sfb, DPR_DST_COORDS, DPR_COORDS(dx, dy));
+	sm712_write_dpr(sfb, DPR_SPAN_COORDS, DPR_COORDS(width, height));
+	sm712_write_dpr(sfb, DPR_DE_CTRL,
+			DE_CTRL_START | DE_CTRL_ROP_ENABLE | direction |
+			(DE_CTRL_COMMAND_BITBLT << DE_CTRL_COMMAND_SHIFT) |
+			(DE_CTRL_ROP_SRC << DE_CTRL_ROP_SHIFT));
+	sm712_read_dpr(sfb, DPR_DE_CTRL);
+	sm712fb_wait(sfb);
+}
+
+void sm712fb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	u32 dx = image->dx, dy = image->dy;
+	u32 width = image->width, height = image->height;
+	u32 fg_color, bg_color;
+
+	struct sm712fb_info *sfb = info->par;
+
+	u32 imgidx = 0;
+	u32 line = image->width >> 3;
+
+	int i, j;
+	u32 total_bytes, total_dwords, remain_bytes;
+
+	if (unlikely(info->state != FBINFO_STATE_RUNNING))
+		return;
+	if ((image->dx >= info->var.xres_virtual) ||
+	    (image->dy >= info->var.yres_virtual))
+		return;
+
+	if (unlikely(image->depth != 1)) {
+		/* unsupported depth, fallback to draw Tux */
+		cfb_imageblit(info, image);
+		return;
+	}
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR ||
+	    info->fix.visual == FB_VISUAL_DIRECTCOLOR) {
+		fg_color = ((u32 *) (info->pseudo_palette))[image->fg_color];
+		bg_color = ((u32 *) (info->pseudo_palette))[image->bg_color];
+	} else {
+		fg_color = image->fg_color;
+		bg_color = image->bg_color;
+	}
+
+	/* total bytes we need to write */
+	total_bytes = (width + 7) / 8;
+
+	/* split the bytes into dwords and remainder bytes */
+	total_dwords = (total_bytes & ~3) / 4;
+	remain_bytes = total_bytes & 3;
+
+	sm712_write_dpr(sfb, DPR_SRC_COORDS, 0);
+	sm712_write_dpr(sfb, DPR_DST_COORDS, DPR_COORDS(dx, dy));
+	sm712_write_dpr(sfb, DPR_SPAN_COORDS, DPR_COORDS(width, height));
+	sm712_write_dpr(sfb, DPR_FG_COLOR, fg_color);
+	sm712_write_dpr(sfb, DPR_BG_COLOR, bg_color);
+
+	sm712_write_dpr(sfb, DPR_DE_CTRL, DE_CTRL_START | DE_CTRL_ROP_ENABLE |
+			(DE_CTRL_COMMAND_HOST_WRITE << DE_CTRL_COMMAND_SHIFT) |
+			(DE_CTRL_HOST_MONO << DE_CTRL_HOST_SHIFT) |
+			(DE_CTRL_ROP_SRC << DE_CTRL_ROP_SHIFT));
+
+	for (i = 0; i < height; i++) {
+		/* cast bytes data into dwords and write to the dataport */
+		for (j = 0; j < total_dwords; j++) {
+			sm712_write_dataport(sfb,
+					     bytes_to_dword(&image->
+							    data[imgidx] +
+							    j * 4, 4));
+		}
+
+		if (remain_bytes) {
+			sm712_write_dataport(sfb,
+					     bytes_to_dword(&image->
+							    data[imgidx] +
+							    (total_dwords * 4),
+							    remain_bytes));
+		}
+		imgidx += line;
+	}
+	sm712_read_dpr(sfb, DPR_DE_CTRL);
+	sm712fb_wait(sfb);
+}
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_accel.h b/drivers/video/fbdev/sm712fb/sm712fb_accel.h
new file mode 100644
index 0000000..6f79177
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_accel.h
@@ -0,0 +1,33 @@
+/*
+ * Silicon Motion SM712 frame buffer device
+ *
+ * Copyright (C) 2006 Silicon Motion Technology Corp.
+ * Authors:  Ge Wang, gewang@siliconmotion.com
+ *	     Boyod boyod.yang@siliconmotion.com.cn
+ *
+ * Copyright (C) 2009 Lemote, Inc.
+ * Author:   Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * Copyright (C) 2011 Igalia, S.L.
+ * Author:   Javier M. Mellid <jmunhoz@igalia.com>
+ *
+ * Copyright (C) 2014 Tom Li.
+ * Author:   Tom Li (Yifeng Li) <biergaizi@member.fsf.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ * Framebuffer driver for Silicon Motion SM712 chip
+ */
+
+#ifndef _SM712FB_ACCEL_H
+#define _SM712FB_ACCEL_H
+
+int sm712fb_init_accel(struct sm712fb_info *fb);
+int sm712fb_wait(struct sm712fb_info *fb);
+void sm712fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect);
+void sm712fb_copyarea(struct fb_info *info, const struct fb_copyarea *area);
+void sm712fb_imageblit(struct fb_info *info, const struct fb_image *image);
+
+#endif
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_drv.c b/drivers/video/fbdev/sm712fb/sm712fb_drv.c
new file mode 100644
index 0000000..7f7cd4f
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_drv.c
@@ -0,0 +1,1022 @@
+/*
+ * Silicon Motion SM712 frame buffer device
+ *
+ * Copyright (C) 2006 Silicon Motion Technology Corp.
+ * Authors:  Ge Wang, gewang@siliconmotion.com
+ *	     Boyod boyod.yang@siliconmotion.com.cn
+ *
+ * Copyright (C) 2009 Lemote, Inc.
+ * Author:   Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * Copyright (C) 2011 Igalia, S.L.
+ * Author:   Javier M. Mellid <jmunhoz@igalia.com>
+ *
+ * Copyright (C) 2014 Tom Li.
+ * Author:   Tom Li (Yifeng Li) <biergaizi@member.fsf.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ * Framebuffer driver for Silicon Motion SM712 chip
+ */
+
+#include <linux/io.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/screen_info.h>
+
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+#include "sm712fb_drv.h"
+#include "sm712fb_accel.h"
+#include "sm712fb_modedb.h"
+
+static struct fb_var_screeninfo sm712fb_var = {
+	.xres = 1024,
+	.yres = 600,
+	.xres_virtual = 1024,
+	.yres_virtual = 600,
+	.bits_per_pixel = 16,
+	.red = {16, 8, 0},
+	.green = {8, 8, 0},
+	.blue = {0, 8, 0},
+	.activate = FB_ACTIVATE_NOW,
+	.height = -1,
+	.width = -1,
+	.vmode = FB_VMODE_NONINTERLACED,
+	.nonstd = 0,
+	.accel_flags = FB_ACCELF_TEXT,
+};
+
+static struct fb_fix_screeninfo sm712fb_fix = {
+	.id = "smXXXfb",
+	.type = FB_TYPE_PACKED_PIXELS,
+	.visual = FB_VISUAL_TRUECOLOR,
+	.line_length = 800 * 3,
+	.accel = FB_ACCEL_SMI_LYNX,
+	.type_aux = 0,
+	.xpanstep = 0,
+	.ypanstep = 0,
+	.ywrapstep = 0,
+};
+
+struct vesa_mode {
+	char index[6];
+	u16 lfb_width;
+	u16 lfb_height;
+	u16 lfb_depth;
+};
+
+static bool accel = 1;
+
+static struct vesa_mode vesa_mode_table[] = {
+	{"0x301", 640, 480, 8},
+	{"0x303", 800, 600, 8},
+	{"0x305", 1024, 768, 8},
+	{"0x307", 1280, 1024, 8},
+
+	{"0x311", 640, 480, 16},
+	{"0x314", 800, 600, 16},
+	{"0x317", 1024, 768, 16},
+	{"0x31A", 1280, 1024, 16},
+
+	{"0x312", 640, 480, 24},
+	{"0x315", 800, 600, 24},
+	{"0x318", 1024, 768, 24},
+	{"0x31B", 1280, 1024, 24},
+};
+
+struct screen_info sm712_scr_info;
+
+static int sm712fb_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+
+		if (!strcmp(this_opt, "accel:0"))
+			accel = false;
+		else if (!strcmp(this_opt, "accel:1"))
+			accel = true;
+	}
+	return 0;
+}
+
+/* process command line options, get vga parameter */
+static int __init sm712_vga_setup(char *options)
+{
+	int i;
+
+	if (!options || !*options)
+		return -EINVAL;
+
+	sm712_scr_info.lfb_width = 0;
+	sm712_scr_info.lfb_height = 0;
+	sm712_scr_info.lfb_depth = 0;
+
+	pr_debug("sm712_vga_setup = %s\n", options);
+
+	for (i = 0; i < ARRAY_SIZE(vesa_mode_table); i++) {
+		if (strstr(options, vesa_mode_table[i].index)) {
+			sm712_scr_info.lfb_width = vesa_mode_table[i].lfb_width;
+			sm712_scr_info.lfb_height =
+			    vesa_mode_table[i].lfb_height;
+			sm712_scr_info.lfb_depth = vesa_mode_table[i].lfb_depth;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+__setup("vga=", sm712_vga_setup);
+
+static void sm712_setpalette(int regno, unsigned red, unsigned green,
+			     unsigned blue, struct fb_info *info)
+{
+	struct sm712fb_info *sfb = info->par;
+
+	/* set bit 5:4 = 01 (write LCD RAM only) */
+	sm712_write_seq(sfb, 0x66, (sm712_read_seq(sfb, 0x66) & 0xC3) | 0x10);
+
+	sm712_writeb(sfb->mmio, DAC_REG, regno);
+	sm712_writeb(sfb->mmio, DAC_VAL, red >> 10);
+	sm712_writeb(sfb->mmio, DAC_VAL, green >> 10);
+	sm712_writeb(sfb->mmio, DAC_VAL, blue >> 10);
+}
+
+/* chan_to_field
+ *
+ * convert a colour value into a field position
+ *
+ * from pxafb.c
+ */
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int sm712_blank(int blank_mode, struct fb_info *info)
+{
+	struct sm712fb_info *sfb = info->par;
+
+	/* clear DPMS setting */
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		/* Screen On: HSync: On, VSync : On */
+		sm712_write_seq(sfb, 0x01,
+				(sm712_read_seq(sfb, 0x01) & (~0x20)));
+		sm712_write_seq(sfb, 0x6a, 0x16);
+		sm712_write_seq(sfb, 0x6b, 0x02);
+		sm712_write_seq(sfb, 0x21, (sm712_read_seq(sfb, 0x21) & 0x77));
+		sm712_write_seq(sfb, 0x22,
+				(sm712_read_seq(sfb, 0x22) & (~0x30)));
+		sm712_write_seq(sfb, 0x23,
+				(sm712_read_seq(sfb, 0x23) & (~0xc0)));
+		sm712_write_seq(sfb, 0x24, (sm712_read_seq(sfb, 0x24) | 0x01));
+		sm712_write_seq(sfb, 0x31, (sm712_read_seq(sfb, 0x31) | 0x03));
+		break;
+	case FB_BLANK_NORMAL:
+		/* Screen Off: HSync: On, VSync : On   Soft blank */
+		sm712_write_seq(sfb, 0x01,
+				(sm712_read_seq(sfb, 0x01) & (~0x20)));
+		sm712_write_seq(sfb, 0x6a, 0x16);
+		sm712_write_seq(sfb, 0x6b, 0x02);
+		sm712_write_seq(sfb, 0x22,
+				(sm712_read_seq(sfb, 0x22) & (~0x30)));
+		sm712_write_seq(sfb, 0x23,
+				(sm712_read_seq(sfb, 0x23) & (~0xc0)));
+		sm712_write_seq(sfb, 0x24, (sm712_read_seq(sfb, 0x24) | 0x01));
+		sm712_write_seq(sfb, 0x31,
+				((sm712_read_seq(sfb, 0x31) & (~0x07)) | 0x00));
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		/* Screen On: HSync: On, VSync : Off */
+		sm712_write_seq(sfb, 0x01, (sm712_read_seq(sfb, 0x01) | 0x20));
+		sm712_write_seq(sfb, 0x20,
+				(sm712_read_seq(sfb, 0x20) & (~0xB0)));
+		sm712_write_seq(sfb, 0x6a, 0x0c);
+		sm712_write_seq(sfb, 0x6b, 0x02);
+		sm712_write_seq(sfb, 0x21, (sm712_read_seq(sfb, 0x21) | 0x88));
+		sm712_write_seq(sfb, 0x22,
+				((sm712_read_seq(sfb, 0x22) & (~0x30)) | 0x20));
+		sm712_write_seq(sfb, 0x23,
+				((sm712_read_seq(sfb, 0x23) & (~0xc0)) | 0x20));
+		sm712_write_seq(sfb, 0x24,
+				(sm712_read_seq(sfb, 0x24) & (~0x01)));
+		sm712_write_seq(sfb, 0x31,
+				((sm712_read_seq(sfb, 0x31) & (~0x07)) | 0x00));
+		sm712_write_seq(sfb, 0x34, (sm712_read_seq(sfb, 0x34) | 0x80));
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* Screen On: HSync: Off, VSync : On */
+		sm712_write_seq(sfb, 0x01, (sm712_read_seq(sfb, 0x01) | 0x20));
+		sm712_write_seq(sfb, 0x20,
+				(sm712_read_seq(sfb, 0x20) & (~0xB0)));
+		sm712_write_seq(sfb, 0x6a, 0x0c);
+		sm712_write_seq(sfb, 0x6b, 0x02);
+		sm712_write_seq(sfb, 0x21, (sm712_read_seq(sfb, 0x21) | 0x88));
+		sm712_write_seq(sfb, 0x22,
+				((sm712_read_seq(sfb, 0x22) & (~0x30)) | 0x10));
+		sm712_write_seq(sfb, 0x23,
+				((sm712_read_seq(sfb, 0x23) & (~0xc0)) | 0xD8));
+		sm712_write_seq(sfb, 0x24,
+				(sm712_read_seq(sfb, 0x24) & (~0x01)));
+		sm712_write_seq(sfb, 0x31,
+				((sm712_read_seq(sfb, 0x31) & (~0x07)) | 0x00));
+		sm712_write_seq(sfb, 0x34, (sm712_read_seq(sfb, 0x34) | 0x80));
+		break;
+	case FB_BLANK_POWERDOWN:
+		/* Screen On: HSync: Off, VSync : Off */
+		sm712_write_seq(sfb, 0x01, (sm712_read_seq(sfb, 0x01) | 0x20));
+		sm712_write_seq(sfb, 0x20,
+				(sm712_read_seq(sfb, 0x20) & (~0xB0)));
+		sm712_write_seq(sfb, 0x6a, 0x5a);
+		sm712_write_seq(sfb, 0x6b, 0x20);
+		sm712_write_seq(sfb, 0x21, (sm712_read_seq(sfb, 0x21) | 0x88));
+		sm712_write_seq(sfb, 0x22,
+				((sm712_read_seq(sfb, 0x22) & (~0x30)) | 0x30));
+		sm712_write_seq(sfb, 0x23,
+				((sm712_read_seq(sfb, 0x23) & (~0xc0)) | 0xD8));
+		sm712_write_seq(sfb, 0x24,
+				(sm712_read_seq(sfb, 0x24) & (~0x01)));
+		sm712_write_seq(sfb, 0x31,
+				((sm712_read_seq(sfb, 0x31) & (~0x07)) | 0x00));
+		sm712_write_seq(sfb, 0x34, (sm712_read_seq(sfb, 0x34) | 0x80));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sm712_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned trans, struct fb_info *info)
+{
+	struct sm712fb_info *sfb;
+	u32 val;
+
+	sfb = info->par;
+
+	if (regno > 255)
+		return 1;
+
+	switch (sfb->fb.fix.visual) {
+	case FB_VISUAL_DIRECTCOLOR:
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16/32 bit true-colour, use pseudo-palette for 16 base color
+		 */
+		if (regno < 16) {
+			if (sfb->fb.var.bits_per_pixel == 16) {
+				u32 *pal = sfb->fb.pseudo_palette;
+
+				val = chan_to_field(red, &sfb->fb.var.red);
+				val |= chan_to_field(green, &sfb->fb.var.green);
+				val |= chan_to_field(blue, &sfb->fb.var.blue);
+#ifdef __BIG_ENDIAN
+				pal[regno] =
+				    ((red & 0xf800) >> 8) |
+				    ((green & 0xe000) >> 13) |
+				    ((green & 0x1c00) << 3) |
+				    ((blue & 0xf800) >> 3);
+#else
+				pal[regno] = val;
+#endif
+			} else {
+				u32 *pal = sfb->fb.pseudo_palette;
+
+				val = chan_to_field(red, &sfb->fb.var.red);
+				val |= chan_to_field(green, &sfb->fb.var.green);
+				val |= chan_to_field(blue, &sfb->fb.var.blue);
+#ifdef __BIG_ENDIAN
+				val =
+				    (val & 0xff00ff00 >> 8) |
+				    (val & 0x00ff00ff << 8);
+#endif
+				pal[regno] = val;
+			}
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		/* color depth 8 bit */
+		sm712_setpalette(regno, red, green, blue, info);
+		break;
+
+	default:
+		return 1;	/* unknown type */
+	}
+
+	return 0;
+
+}
+
+#ifdef __BIG_ENDIAN
+static ssize_t sm712fb_read(struct fb_info *info, char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	unsigned long p = *ppos;
+
+	u32 *buffer, *dst;
+	u32 __iomem *src;
+	int c, i, cnt = 0, err = 0;
+	unsigned long total_size;
+
+	if (!info || !info->screen_base)
+		return -ENODEV;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	total_size = info->screen_size;
+
+	if (total_size == 0)
+		total_size = info->fix.smem_len;
+
+	if (p >= total_size)
+		return 0;
+
+	if (count >= total_size)
+		count = total_size;
+
+	if (count + p > total_size)
+		count = total_size - p;
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	src = (u32 __iomem *) (info->screen_base + p);
+
+	if (info->fbops->fb_sync)
+		info->fbops->fb_sync(info);
+
+	while (count) {
+		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		dst = buffer;
+		for (i = c >> 2; i--;) {
+			*dst = fb_readl(src++);
+			*dst =
+			    (*dst & 0xff00ff00 >> 8) | (*dst & 0x00ff00ff << 8);
+			dst++;
+		}
+		if (c & 3) {
+			u8 *dst8 = (u8 *) dst;
+			u8 __iomem *src8 = (u8 __iomem *) src;
+
+			for (i = c & 3; i--;) {
+				if (i & 1) {
+					*dst8++ = fb_readb(++src8);
+				} else {
+					*dst8++ = fb_readb(--src8);
+					src8 += 2;
+				}
+			}
+			src = (u32 __iomem *) src8;
+		}
+
+		if (copy_to_user(buf, buffer, c)) {
+			err = -EFAULT;
+			break;
+		}
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (err) ? err : cnt;
+}
+
+static ssize_t
+sm712fb_write(struct fb_info *info, const char __user *buf, size_t count,
+	      loff_t *ppos)
+{
+	unsigned long p = *ppos;
+
+	u32 *buffer, *src;
+	u32 __iomem *dst;
+	int c, i, cnt = 0, err = 0;
+	unsigned long total_size;
+
+	if (!info || !info->screen_base)
+		return -ENODEV;
+
+	if (info->state != FBINFO_STATE_RUNNING)
+		return -EPERM;
+
+	total_size = info->screen_size;
+
+	if (total_size == 0)
+		total_size = info->fix.smem_len;
+
+	if (p > total_size)
+		return -EFBIG;
+
+	if (count > total_size) {
+		err = -EFBIG;
+		count = total_size;
+	}
+
+	if (count + p > total_size) {
+		if (!err)
+			err = -ENOSPC;
+
+		count = total_size - p;
+	}
+
+	buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	dst = (u32 __iomem *) (info->screen_base + p);
+
+	if (info->fbops->fb_sync)
+		info->fbops->fb_sync(info);
+
+	while (count) {
+		c = (count > PAGE_SIZE) ? PAGE_SIZE : count;
+		src = buffer;
+
+		if (copy_from_user(src, buf, c)) {
+			err = -EFAULT;
+			break;
+		}
+
+		for (i = c >> 2; i--;) {
+			fb_writel((*src & 0xff00ff00 >> 8) |
+				  (*src & 0x00ff00ff << 8), dst++);
+			src++;
+		}
+		if (c & 3) {
+			u8 *src8 = (u8 *) src;
+			u8 __iomem *dst8 = (u8 __iomem *) dst;
+
+			for (i = c & 3; i--;) {
+				if (i & 1) {
+					fb_writeb(*src8++, ++dst8);
+				} else {
+					fb_writeb(*src8++, --dst8);
+					dst8 += 2;
+				}
+			}
+			dst = (u32 __iomem *) dst8;
+		}
+
+		*ppos += c;
+		buf += c;
+		cnt += c;
+		count -= c;
+	}
+
+	kfree(buffer);
+
+	return (cnt) ? cnt : err;
+}
+#endif /* ! __BIG_ENDIAN */
+
+static void sm712_set_timing(struct sm712fb_info *sfb)
+{
+	int i = 0, j = 0;
+	u32 m_nScreenStride;
+
+	dev_dbg(&sfb->pdev->dev,
+		"sfb->width=%d sfb->height=%d "
+		"sfb->fb.var.bits_per_pixel=%d sfb->hz=%d\n",
+		sfb->width, sfb->height, sfb->fb.var.bits_per_pixel, sfb->hz);
+
+	for (j = 0; j < numVGAModes; j++) {
+		if (VGAMode[j].mmSizeX != sfb->width ||
+		    VGAMode[j].mmSizeY != sfb->height ||
+		    VGAMode[j].bpp != sfb->fb.var.bits_per_pixel ||
+		    VGAMode[j].hz != sfb->hz) {
+			continue;
+		}
+
+		dev_dbg(&sfb->pdev->dev,
+			"VGAMode[j].mmSizeX=%d VGAMode[j].mmSizeY=%d "
+			"VGAMode[j].bpp=%d VGAMode[j].hz=%d\n",
+			VGAMode[j].mmSizeX, VGAMode[j].mmSizeY,
+			VGAMode[j].bpp, VGAMode[j].hz);
+
+		dev_dbg(&sfb->pdev->dev, "VGAMode index=%d\n", j);
+
+		sm712_writeb(sfb->mmio, 0x3c6, 0x0);
+
+		sm712_write_seq(sfb, 0, 0x1);
+
+		sm712_writeb(sfb->mmio, 0x3c2, VGAMode[j].Init_MISC);
+
+		/* init SEQ register SR00 - SR04 */
+		for (i = 0; i < SR00_SR04_SIZE; i++)
+			sm712_write_seq(sfb, i, VGAMode[j].Init_SR00_SR04[i]);
+
+		/* init SEQ register SR10 - SR24 */
+		for (i = 0; i < SR10_SR24_SIZE; i++)
+			sm712_write_seq(sfb, i + 0x10,
+					VGAMode[j].Init_SR10_SR24[i]);
+
+		/* init SEQ register SR30 - SR75 */
+		for (i = 0; i < SR30_SR75_SIZE; i++)
+			if ((i + 0x30) != 0x62 &&
+			    (i + 0x30) != 0x6a && (i + 0x30) != 0x6b)
+				sm712_write_seq(sfb, i + 0x30,
+						VGAMode[j].Init_SR30_SR75[i]);
+
+		/* init SEQ register SR80 - SR93 */
+		for (i = 0; i < SR80_SR93_SIZE; i++)
+			sm712_write_seq(sfb, i + 0x80,
+					VGAMode[j].Init_SR80_SR93[i]);
+
+		/* init SEQ register SRA0 - SRAF */
+		for (i = 0; i < SRA0_SRAF_SIZE; i++)
+			sm712_write_seq(sfb, i + 0xa0,
+					VGAMode[j].Init_SRA0_SRAF[i]);
+
+		/* init Graphic register GR00 - GR08 */
+		for (i = 0; i < GR00_GR08_SIZE; i++)
+			sm712_write_grph(sfb, i, VGAMode[j].Init_GR00_GR08[i]);
+
+		/* init Attribute register AR00 - AR14 */
+		for (i = 0; i < AR00_AR14_SIZE; i++)
+			sm712_write_attr(sfb, i, VGAMode[j].Init_AR00_AR14[i]);
+
+		/* init CRTC register CR00 - CR18 */
+		for (i = 0; i < CR00_CR18_SIZE; i++)
+			sm712_write_crtc(sfb, i, VGAMode[j].Init_CR00_CR18[i]);
+
+		/* init CRTC register CR30 - CR4D */
+		for (i = 0; i < CR30_CR4D_SIZE; i++)
+			sm712_write_crtc(sfb, i + 0x30,
+					 VGAMode[j].Init_CR30_CR4D[i]);
+
+		/* init CRTC register CR90 - CRA7 */
+		for (i = 0; i < CR90_CRA7_SIZE; i++)
+			sm712_write_crtc(sfb, i + 0x90,
+					 VGAMode[j].Init_CR90_CRA7[i]);
+	}
+	sm712_writeb(sfb->mmio, 0x3c2, 0x67);
+
+	/* set VPR registers */
+	sm712_writel(sfb->vpr, 0x0C, 0x0);
+	sm712_writel(sfb->vpr, 0x40, 0x0);
+
+	/* set data width */
+	m_nScreenStride = (sfb->width * sfb->fb.var.bits_per_pixel) / 64;
+	switch (sfb->fb.var.bits_per_pixel) {
+	case 8:
+		sm712_writel(sfb->vpr, 0x0, 0x0);
+		break;
+	case 16:
+		sm712_writel(sfb->vpr, 0x0, 0x00020000);
+		break;
+	case 24:
+		sm712_writel(sfb->vpr, 0x0, 0x00040000);
+		break;
+	case 32:
+		sm712_writel(sfb->vpr, 0x0, 0x00030000);
+		break;
+	}
+	sm712_writel(sfb->vpr, 0x10,
+		     (u32) (((m_nScreenStride + 2) << 16) | m_nScreenStride));
+}
+
+static void sm712fb_setmode(struct sm712fb_info *sfb)
+{
+	switch (sfb->fb.var.bits_per_pixel) {
+	case 32:
+		sfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length = sfb->fb.var.xres * 4;
+		sfb->fb.var.red.length = 8;
+		sfb->fb.var.green.length = 8;
+		sfb->fb.var.blue.length = 8;
+		sfb->fb.var.red.offset = 16;
+		sfb->fb.var.green.offset = 8;
+		sfb->fb.var.blue.offset = 0;
+		break;
+	case 24:
+		sfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length = sfb->fb.var.xres * 3;
+		sfb->fb.var.red.length = 8;
+		sfb->fb.var.green.length = 8;
+		sfb->fb.var.blue.length = 8;
+		sfb->fb.var.red.offset = 16;
+		sfb->fb.var.green.offset = 8;
+		sfb->fb.var.blue.offset = 0;
+		break;
+	case 8:
+		sfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		sfb->fb.fix.line_length = sfb->fb.var.xres;
+		sfb->fb.var.red.length = 3;
+		sfb->fb.var.green.length = 3;
+		sfb->fb.var.blue.length = 2;
+		sfb->fb.var.red.offset = 5;
+		sfb->fb.var.green.offset = 2;
+		sfb->fb.var.blue.offset = 0;
+		break;
+	case 16:
+	default:
+		sfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;
+		sfb->fb.fix.line_length = sfb->fb.var.xres * 2;
+		sfb->fb.var.red.length = 5;
+		sfb->fb.var.green.length = 6;
+		sfb->fb.var.blue.length = 5;
+		sfb->fb.var.red.offset = 11;
+		sfb->fb.var.green.offset = 5;
+		sfb->fb.var.blue.offset = 0;
+		break;
+	}
+
+	sfb->width = sfb->fb.var.xres;
+	sfb->height = sfb->fb.var.yres;
+	sfb->hz = 60;
+	sm712_set_timing(sfb);
+}
+
+static int sm712_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	/* sanity checks */
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	/* set valid default bpp */
+	if ((var->bits_per_pixel != 8) && (var->bits_per_pixel != 16) &&
+	    (var->bits_per_pixel != 24) && (var->bits_per_pixel != 32))
+		var->bits_per_pixel = 16;
+
+	return 0;
+}
+
+static int sm712_set_par(struct fb_info *info)
+{
+	sm712fb_setmode(info->par);
+
+	return 0;
+}
+
+static struct fb_ops sm712fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = sm712_check_var,
+	.fb_set_par = sm712_set_par,
+	.fb_setcolreg = sm712_setcolreg,
+	.fb_blank = sm712_blank,
+	.fb_fillrect = cfb_fillrect,
+	.fb_imageblit = cfb_imageblit,
+	.fb_copyarea = cfb_copyarea,
+#ifdef __BIG_ENDIAN
+	.fb_read = sm712fb_read,
+	.fb_write = sm712fb_write,
+#endif
+};
+
+/*
+ * alloc struct sm712fb_info and assign default values
+ */
+static struct sm712fb_info *sm712_fb_info_new(struct pci_dev *pdev)
+{
+	struct sm712fb_info *sfb;
+
+	sfb = kzalloc(sizeof(*sfb), GFP_KERNEL);
+
+	if (!sfb)
+		return NULL;
+
+	sfb->pdev = pdev;
+
+	sfb->fb.flags = FBINFO_FLAG_DEFAULT;
+	sfb->fb.fbops = &sm712fb_ops;
+	sfb->fb.fix = sm712fb_fix;
+	sfb->fb.var = sm712fb_var;
+	sfb->fb.pseudo_palette = sfb->colreg;
+	sfb->fb.par = sfb;
+	sfb->accel = accel;
+
+	return sfb;
+}
+
+/*
+ * free struct sm712fb_info
+ */
+static void sm712_fb_info_free(struct sm712fb_info *sfb)
+{
+	kfree(sfb);
+}
+
+/*
+ * Map in the screen memory
+ */
+
+static int sm712_map_smem(struct sm712fb_info *sfb,
+			  struct pci_dev *pdev, u_long smem_len)
+{
+
+	sfb->fb.fix.smem_start = pci_resource_start(pdev, 0);
+
+#ifdef __BIG_ENDIAN
+	if (sfb->fb.var.bits_per_pixel == 32)
+		sfb->fb.fix.smem_start += 0x800000;
+#endif
+
+	sfb->fb.fix.smem_len = smem_len;
+
+	sfb->fb.screen_base = sfb->lfb;
+
+	if (!sfb->fb.screen_base) {
+		dev_err(&pdev->dev,
+			"%s: unable to map screen memory\n", sfb->fb.fix.id);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * Unmap in the screen memory
+ *
+ */
+static void sm712_unmap_smem(struct sm712fb_info *sfb)
+{
+	if (sfb && sfb->fb.screen_base) {
+		iounmap(sfb->fb.screen_base);
+		sfb->fb.screen_base = NULL;
+		sfb->lfb = NULL;
+	}
+}
+
+static inline void sm712_init_hw(struct sm712fb_info *sfb)
+{
+	/* enable linear memory mode and packed pixel format */
+	outb_p(0x18, 0x3c4);
+	outb_p(0x11, 0x3c5);
+
+	/* set MCLK = 14.31818 *  (0x16 / 0x2) */
+	sm712_write_seq(sfb, 0x6a, 0x16);
+	sm712_write_seq(sfb, 0x6b, 0x02);
+	sm712_write_seq(sfb, 0x62, 0x3e);
+
+	/* enable PCI burst */
+	sm712_write_seq(sfb, 0x17, 0x20);
+
+#ifdef __BIG_ENDIAN
+	/* enable word swap */
+	if (sfb->fb.var.bits_per_pixel == 32)
+		sm712_write_seq(sfb, 0x17, 0x30);
+#endif
+
+	if (!sfb->accel) {
+		dev_info(&sfb->pdev->dev, "2d acceleration was disabled by user.\n");
+		sfb->fb.flags = FBINFO_FLAG_DEFAULT | FBINFO_HWACCEL_NONE;
+		return;
+	}
+
+	if (sm712fb_init_accel(sfb) < 0) {
+		dev_info(&sfb->pdev->dev, "failed to enable 2d accleration.\n");
+		sfb->fb.flags = FBINFO_FLAG_DEFAULT | FBINFO_HWACCEL_NONE;
+		return;
+	} else {
+		sm712fb_ops.fb_fillrect = sm712fb_fillrect;
+		sm712fb_ops.fb_copyarea = sm712fb_copyarea;
+		sm712fb_ops.fb_imageblit = sm712fb_imageblit;
+		sfb->fb.flags |= FBINFO_HWACCEL_COPYAREA |
+				 FBINFO_HWACCEL_FILLRECT |
+				 FBINFO_HWACCEL_IMAGEBLIT |
+				 FBINFO_READS_FAST;
+		dev_info(&sfb->pdev->dev, "sm712fb: enable 2d acceleration.\n");
+	}
+}
+
+static int sm712fb_pci_probe(struct pci_dev *pdev,
+			     const struct pci_device_id *ent)
+{
+	struct sm712fb_info *sfb;
+	int err;
+	unsigned long mmio_base;
+
+#ifndef MODULE
+	char *option = NULL;
+
+	if (!fb_get_options("sm712fb", &option))
+		sm712fb_setup(option);
+#endif
+
+	dev_info(&pdev->dev, "Silicon Motion display driver.");
+
+	err = pci_enable_device(pdev);	/* enable SMTC chip */
+	if (err)
+		return err;
+
+	sprintf(sm712fb_fix.id, "sm712fb");
+
+	sfb = sm712_fb_info_new(pdev);
+
+	if (!sfb) {
+		err = -ENOMEM;
+		goto free_fail;
+	}
+
+	sfb->chip_id = ent->device;
+
+	pci_set_drvdata(pdev, sfb);
+
+	/* get mode parameter from sm712_scr_info */
+	if (sm712_scr_info.lfb_width != 0) {
+		sfb->fb.var.xres = sm712_scr_info.lfb_width;
+		sfb->fb.var.yres = sm712_scr_info.lfb_height;
+		sfb->fb.var.bits_per_pixel = sm712_scr_info.lfb_depth;
+	} else {
+		/* default resolution 1024x600 16bit mode */
+		sfb->fb.var.xres = SM712_DEFAULT_XRES;
+		sfb->fb.var.yres = SM712_DEFAULT_YRES;
+		sfb->fb.var.bits_per_pixel = SM712_DEFAULT_BPP;
+	}
+
+#ifdef __BIG_ENDIAN
+	if (sfb->fb.var.bits_per_pixel == 24)
+		sfb->fb.var.bits_per_pixel = (sm712_scr_info.lfb_depth = 32);
+#endif
+
+	/* Map address and memory detection */
+	mmio_base = pci_resource_start(pdev, 0);
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &sfb->chip_rev_id);
+
+	if (sfb->chip_id != 0x712) {
+		dev_err(&pdev->dev,
+			"No valid Silicon Motion display chip was detected!");
+
+		goto fb_fail;
+	}
+
+	sfb->fb.fix.mmio_start = mmio_base + SM712_REG_BASE;
+	sfb->fb.fix.mmio_len = SM712_REG_SIZE;
+#ifdef __BIG_ENDIAN
+	sfb->lfb = ioremap(mmio_base, 0x00c00000);
+#else
+	sfb->lfb = ioremap(mmio_base, 0x00800000);
+#endif
+	sfb->mmio = sfb->lfb + SM712_MMIO_BASE;
+	sfb->dpr = sfb->lfb + SM712_DPR_BASE;
+	sfb->vpr = sfb->lfb + SM712_VPR_BASE;
+	sfb->dataport = sfb->lfb + SM712_DATAPORT_BASE;
+#ifdef __BIG_ENDIAN
+	if (sfb->fb.var.bits_per_pixel == 32) {
+		sfb->lfb += 0x800000;
+		dev_info(&pdev->dev, "sfb->lfb=%p", sfb->lfb);
+	}
+#endif
+	if (!sfb->mmio) {
+		dev_err(&pdev->dev,
+			"%s: unable to map memory mapped IO!", sfb->fb.fix.id);
+		err = -ENOMEM;
+		goto fb_fail;
+	}
+
+	sm712_init_hw(sfb);
+
+	/* can support 32 bpp */
+	if (15 == sfb->fb.var.bits_per_pixel)
+		sfb->fb.var.bits_per_pixel = 16;
+
+	sfb->fb.var.xres_virtual = sfb->fb.var.xres;
+	sfb->fb.var.yres_virtual = sfb->fb.var.yres;
+	err = sm712_map_smem(sfb, pdev, SM712_VRAM_SIZE);
+	if (err)
+		goto fail;
+
+	sm712fb_setmode(sfb);
+
+	err = register_framebuffer(&sfb->fb);
+	if (err < 0)
+		goto fail;
+
+	dev_info(&pdev->dev,
+		 "Silicon Motion SM%X Rev%X primary display mode %dx%d-%d Init Complete.",
+		 sfb->chip_id, sfb->chip_rev_id, sfb->fb.var.xres,
+		 sfb->fb.var.yres, sfb->fb.var.bits_per_pixel);
+
+	return 0;
+
+fail:
+	dev_err(&pdev->dev, "Silicon Motion, Inc. primary display init fail.");
+
+	sm712_unmap_smem(sfb);
+fb_fail:
+	sm712_fb_info_free(sfb);
+free_fail:
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+/*
+ * 0x712 (LynxEM+)
+ */
+static const struct pci_device_id sm712fb_pci_table[] = {
+	{PCI_DEVICE(0x126f, 0x712),},
+	{0,}
+};
+
+static void sm712fb_pci_remove(struct pci_dev *pdev)
+{
+	struct sm712fb_info *sfb;
+
+	sfb = pci_get_drvdata(pdev);
+	sm712_unmap_smem(sfb);
+	unregister_framebuffer(&sfb->fb);
+	sm712_fb_info_free(sfb);
+}
+
+#ifdef CONFIG_PM
+static int sm712fb_pci_suspend(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct sm712fb_info *sfb;
+
+	sfb = pci_get_drvdata(pdev);
+
+	/* set the hw in sleep mode use external clock and self memory refresh
+	 * so that we can turn off internal PLLs later on
+	 */
+	sm712_write_seq(sfb, 0x20, (sm712_read_seq(sfb, 0x20) | 0xc0));
+	sm712_write_seq(sfb, 0x69, (sm712_read_seq(sfb, 0x69) & 0xf7));
+
+	console_lock();
+	fb_set_suspend(&sfb->fb, 1);
+	console_unlock();
+
+	/* additionally turn off all function blocks including internal PLLs */
+	sm712_write_seq(sfb, 0x21, 0xff);
+
+	return 0;
+}
+
+static int sm712fb_pci_resume(struct device *device)
+{
+	struct pci_dev *pdev = to_pci_dev(device);
+	struct sm712fb_info *sfb;
+
+	sfb = pci_get_drvdata(pdev);
+
+	/* reinit hardware */
+	sm712_init_hw(sfb);
+
+	sm712_write_seq(sfb, 0x34, (sm712_read_seq(sfb, 0x34) | 0xc0));
+	sm712_write_seq(sfb, 0x33, ((sm712_read_seq(sfb, 0x33) | 0x08) & 0xfb));
+
+	sm712fb_setmode(sfb);
+
+	console_lock();
+	fb_set_suspend(&sfb->fb, 0);
+	console_unlock();
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(sm712_pm_ops, sm712fb_pci_suspend, sm712fb_pci_resume);
+#define SM712_PM_OPS (&sm712_pm_ops)
+
+#else /* !CONFIG_PM */
+
+#define SM712_PM_OPS NULL
+
+#endif /* !CONFIG_PM */
+
+static struct pci_driver sm712fb_driver = {
+	.name = "sm712fb",
+	.id_table = sm712fb_pci_table,
+	.probe = sm712fb_pci_probe,
+	.remove = sm712fb_pci_remove,
+	.driver.pm = SM712_PM_OPS,
+};
+
+module_pci_driver(sm712fb_driver);
+
+module_param(accel, bool, S_IRUGO);
+MODULE_PARM_DESC(accel, "Enable or disable 2D Acceleration");
+
+MODULE_AUTHOR("Siliconmotion ");
+MODULE_DESCRIPTION("Framebuffer driver for Silicon Motion SM712 Graphic Cards");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_drv.h b/drivers/video/fbdev/sm712fb/sm712fb_drv.h
new file mode 100644
index 0000000..bf81bff
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_drv.h
@@ -0,0 +1,130 @@
+/*
+ * Silicon Motion SM712 frame buffer device
+ *
+ * Copyright (C) 2006 Silicon Motion Technology Corp.
+ * Authors:  Ge Wang, gewang@siliconmotion.com
+ *	     Boyod boyod.yang@siliconmotion.com.cn
+ *
+ * Copyright (C) 2009 Lemote, Inc.
+ * Author:   Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * Copyright (C) 2011 Igalia, S.L.
+ * Author:   Javier M. Mellid <jmunhoz@igalia.com>
+ *
+ * Copyright (C) 2014 Tom Li.
+ * Author:   Tom Li (Yifeng Li) <biergaizi@member.fsf.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ * Framebuffer driver for Silicon Motion SM712 chip
+ */
+
+#ifndef _SM712FB_DRV_H
+#define _SM712FB_DRV_H
+
+/*
+* Private structure
+*/
+struct sm712fb_info {
+	struct pci_dev *pdev;
+	struct fb_info fb;
+	u16 chip_id;
+	u8  chip_rev_id;
+
+	void __iomem *lfb;	/* linear frame buffer, the base address */
+
+	void __iomem *dpr;	/* drawing processor control regs */
+	void __iomem *vpr;	/* video processor control regs */
+	void __iomem *cpr;	/* capture processor control regs */
+	void __iomem *mmio;	/* memory map IO port */
+	void __iomem *dataport; /* 2d drawing engine data port */
+
+	u_int width;
+	u_int height;
+	u_int hz;
+
+	u32 colreg[17];
+
+	bool accel;
+};
+
+/* constants for registers operations */
+
+#include "sm712fb_io.h"
+
+#define FB_ACCEL_SMI_LYNX		88
+
+#define SM712_DEFAULT_XRES		1024
+#define SM712_DEFAULT_YRES		600
+#define SM712_DEFAULT_BPP		16
+
+#define SM712_VRAM_SIZE			0x00400000
+
+#define	SM712_REG_BASE			0x00400000
+#define SM712_REG_SIZE                  0x00400000
+
+#define	SM712_MMIO_BASE			0x00700000
+
+#define	SM712_DPR_BASE			0x00408000
+#define SM712_DPR_SIZE                  (0x6C + 1)
+
+#define	DPR_COORDS(x, y)		(((x) << 16) | (y))
+
+#define	DPR_SRC_COORDS			0x00
+#define	DPR_DST_COORDS			0x04
+#define	DPR_SPAN_COORDS			0x08
+#define	DPR_DE_CTRL			0x0c
+#define	DPR_PITCH			0x10
+#define	DPR_FG_COLOR			0x14
+#define	DPR_BG_COLOR			0x18
+#define	DPR_STRETCH			0x1c
+#define	DPR_COLOR_COMPARE		0x20
+#define	DPR_COLOR_COMPARE_MASK		0x24
+#define	DPR_BYTE_BIT_MASK		0x28
+#define	DPR_CROP_TOPLEFT_COORDS		0x2c
+#define	DPR_CROP_BOTRIGHT_COORDS	0x30
+#define	DPR_SRC_WINDOW			0x3c
+#define	DPR_SRC_BASE			0x40
+#define	DPR_DST_BASE			0x44
+
+#define	DE_CTRL_START			0x80000000
+#define	DE_CTRL_RTOL			0x08000000
+#define	DE_CTRL_COMMAND_MASK		0x001f0000
+#define	DE_CTRL_COMMAND_SHIFT			16
+#define	DE_CTRL_COMMAND_BITBLT			0x00
+#define	DE_CTRL_COMMAND_SOLIDFILL		0x01
+#define DE_CTRL_COMMAND_HOST_WRITE              0x08
+#define	DE_CTRL_ROP_ENABLE		0x00008000
+#define	DE_CTRL_ROP_MASK		0x000000ff
+#define	DE_CTRL_ROP_SHIFT			0
+#define	DE_CTRL_ROP_SRC				0x0c
+
+#define DE_CTRL_HOST_SHIFT              22
+#define DE_CTRL_HOST_MONO               1
+
+#define SCR_DE_STATUS			0x16
+#define SCR_DE_STATUS_MASK		0x18
+#define SCR_DE_ENGINE_IDLE		0x10
+
+#define	SM712_VPR_BASE			0x0040c000
+#define SM712_VPR_SIZE                  (0x44 + 1)
+
+#define SM712_DATAPORT_BASE             0x00400000
+
+#define SR00_SR04_SIZE      (0x04 - 0x00 + 1)
+#define SR10_SR24_SIZE      (0x24 - 0x10 + 1)
+#define SR30_SR75_SIZE      (0x75 - 0x30 + 1)
+#define SR80_SR93_SIZE      (0x93 - 0x80 + 1)
+#define SRA0_SRAF_SIZE      (0xAF - 0xA0 + 1)
+#define GR00_GR08_SIZE      (0x08 - 0x00 + 1)
+#define AR00_AR14_SIZE      (0x14 - 0x00 + 1)
+#define CR00_CR18_SIZE      (0x18 - 0x00 + 1)
+#define CR30_CR4D_SIZE      (0x4D - 0x30 + 1)
+#define CR90_CRA7_SIZE      (0xA7 - 0x90 + 1)
+
+#define DAC_REG	(0x3c8)
+#define DAC_VAL	(0x3c9)
+
+#endif
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_io.h b/drivers/video/fbdev/sm712fb/sm712fb_io.h
new file mode 100644
index 0000000..93346a0
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_io.h
@@ -0,0 +1,90 @@
+/*
+ * Silicon Motion SM712 frame buffer device
+ *
+ * Copyright (C) 2006 Silicon Motion Technology Corp.
+ * Authors:  Ge Wang, gewang@siliconmotion.com
+ *	     Boyod boyod.yang@siliconmotion.com.cn
+ *
+ * Copyright (C) 2009 Lemote, Inc.
+ * Author:   Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * Copyright (C) 2011 Igalia, S.L.
+ * Author:   Javier M. Mellid <jmunhoz@igalia.com>
+ *
+ * Copyright (C) 2014 Tom Li.
+ * Author:   Tom Li (Yifeng Li) <biergaizi@member.fsf.org>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+
+
+#define sm712_writeb(base, reg, dat)	writeb(dat, base + reg)
+#define sm712_writew(base, reg, dat)	writew(dat, base + reg)
+#define sm712_writel(base, reg, dat)	writel(dat, base + reg)
+
+#define sm712_readb(base, reg)	readb(base + reg)
+#define sm712_readw(base, reg)	readw(base + reg)
+#define sm712_readl(base, reg)	readl(base + reg)
+
+
+static inline void sm712_write_crtc(struct sm712fb_info *fb, u8 reg, u8 val)
+{
+	sm712_writeb(fb->mmio, 0x3d4, reg);
+	sm712_writeb(fb->mmio, 0x3d5, val);
+}
+
+static inline u8 sm712_read_crtc(struct sm712fb_info *fb, u8 reg)
+{
+	sm712_writeb(fb->mmio, 0x3d4, reg);
+	return sm712_readb(fb->mmio, 0x3d5);
+}
+
+static inline void sm712_write_grph(struct sm712fb_info *fb, u8 reg, u8 val)
+{
+	sm712_writeb(fb->mmio, 0x3ce, reg);
+	sm712_writeb(fb->mmio, 0x3cf, val);
+}
+
+static inline u8 sm712_read_grph(struct sm712fb_info *fb, u8 reg)
+{
+	sm712_writeb(fb->mmio, 0x3ce, reg);
+	return sm712_readb(fb->mmio, 0x3cf);
+}
+
+static inline void sm712_write_attr(struct sm712fb_info *fb, u8 reg, u8 val)
+{
+	sm712_readb(fb->mmio, 0x3da);
+	sm712_writeb(fb->mmio, 0x3c0, reg);
+	sm712_readb(fb->mmio, 0x3c1);
+	sm712_writeb(fb->mmio, 0x3c0, val);
+}
+
+static inline void sm712_write_seq(struct sm712fb_info *fb, u8 reg, u8 val)
+{
+	sm712_writeb(fb->mmio, 0x3c4, reg);
+	sm712_writeb(fb->mmio, 0x3c5, val);
+}
+
+static inline u8 sm712_read_seq(struct sm712fb_info *fb, u8 reg)
+{
+	sm712_writeb(fb->mmio, 0x3c4, reg);
+	return sm712_readb(fb->mmio, 0x3c5);
+}
+
+static inline u32 sm712_read_dpr(struct sm712fb_info *fb, u8 reg)
+{
+	return sm712_readl(fb->dpr, reg);
+}
+
+static inline void sm712_write_dpr(struct sm712fb_info *fb, u8 reg, u32 val)
+{
+	sm712_writel(fb->dpr, reg, val);
+}
+
+static inline void sm712_write_dataport(struct sm712fb_info *fb, u32 val)
+{
+	sm712_writel(fb->dataport, 0, val);
+}
diff --git a/drivers/video/fbdev/sm712fb/sm712fb_modedb.h b/drivers/video/fbdev/sm712fb/sm712fb_modedb.h
new file mode 100644
index 0000000..16ee7e3
--- /dev/null
+++ b/drivers/video/fbdev/sm712fb/sm712fb_modedb.h
@@ -0,0 +1,682 @@
+/* The next structure holds all information relevant for a specific video mode.
+ */
+
+struct ModeInit {
+	int mmSizeX;
+	int mmSizeY;
+	int bpp;
+	int hz;
+	unsigned char Init_MISC;
+	unsigned char Init_SR00_SR04[SR00_SR04_SIZE];
+	unsigned char Init_SR10_SR24[SR10_SR24_SIZE];
+	unsigned char Init_SR30_SR75[SR30_SR75_SIZE];
+	unsigned char Init_SR80_SR93[SR80_SR93_SIZE];
+	unsigned char Init_SRA0_SRAF[SRA0_SRAF_SIZE];
+	unsigned char Init_GR00_GR08[GR00_GR08_SIZE];
+	unsigned char Init_AR00_AR14[AR00_AR14_SIZE];
+	unsigned char Init_CR00_CR18[CR00_CR18_SIZE];
+	unsigned char Init_CR30_CR4D[CR30_CR4D_SIZE];
+	unsigned char Init_CR90_CRA7[CR90_CRA7_SIZE];
+};
+
+/**********************************************************************
+			 SM712 Mode table.
+ **********************************************************************/
+struct ModeInit VGAMode[] = {
+	{
+	 /*  mode#0: 640 x 480  16Bpp  60Hz */
+	 640, 480, 16, 60,
+	 /*  Init_MISC */
+	 0xE3,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x00, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+	  0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+	  0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+	  0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+	  0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+	  0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+	  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+	  0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+	  0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+	  0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+	  0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+	  },
+	 },
+	{
+	 /*  mode#1: 640 x 480  24Bpp  60Hz */
+	 640, 480, 24, 60,
+	 /*  Init_MISC */
+	 0xE3,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x00, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+	  0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+	  0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+	  0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+	  0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+	  0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+	  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+	  0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+	  0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+	  0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+	  0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+	  },
+	 },
+	{
+	 /*  mode#0: 640 x 480  32Bpp  60Hz */
+	 640, 480, 32, 60,
+	 /*  Init_MISC */
+	 0xE3,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x00, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEF, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x32, 0x03, 0xA0, 0x09, 0xC0, 0x32, 0x32, 0x32,
+	  0x32, 0x32, 0x32, 0x32, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x32, 0x32, 0x32,
+	  0x04, 0x24, 0x63, 0x4F, 0x52, 0x0B, 0xDF, 0xEA,
+	  0x04, 0x50, 0x19, 0x32, 0x32, 0x00, 0x00, 0x32,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x07, 0x82, 0x07, 0x04,
+	  0x00, 0x45, 0x30, 0x30, 0x40, 0x30,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x32,
+	  0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x32, 0x32,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xFF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x5F, 0x4F, 0x4F, 0x00, 0x53, 0x1F, 0x0B, 0x3E,
+	  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xEA, 0x0C, 0xDF, 0x50, 0x40, 0xDF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xFF, 0xFD,
+	  0x5F, 0x4F, 0x00, 0x54, 0x00, 0x0B, 0xDF, 0x00,
+	  0xEA, 0x0C, 0x2E, 0x00, 0x4F, 0xDF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0xDD, 0x5E, 0xEA, 0x87, 0x44, 0x8F, 0x55,
+	  0x0A, 0x8F, 0x55, 0x0A, 0x00, 0x00, 0x18, 0x00,
+	  0x11, 0x10, 0x0B, 0x0A, 0x0A, 0x0A, 0x0A, 0x00,
+	  },
+	 },
+
+	{			/*  mode#2: 800 x 600  16Bpp  60Hz */
+	 800, 600, 16, 60,
+	 /*  Init_MISC */
+	 0x2B,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x34, 0x03, 0x20, 0x09, 0xC0, 0x24, 0x24, 0x24,
+	  0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x38, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x24, 0x24, 0x24,
+	  0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+	  0x04, 0x55, 0x59, 0x24, 0x24, 0x00, 0x00, 0x24,
+	  0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+	  0x02, 0x45, 0x30, 0x35, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0x00, 0x00, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x24,
+	  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x24, 0x24,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+	  0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+	  0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+	  0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+	  0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+	  },
+	 },
+	{			/*  mode#3: 800 x 600  24Bpp  60Hz */
+	 800, 600, 24, 60,
+	 0x2B,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x36, 0x03, 0x20, 0x09, 0xC0, 0x36, 0x36, 0x36,
+	  0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x36, 0x36, 0x36,
+	  0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+	  0x04, 0x55, 0x59, 0x36, 0x36, 0x00, 0x00, 0x36,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+	  0x02, 0x45, 0x30, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x36,
+	  0xF7, 0x00, 0x00, 0x00, 0xEF, 0xFF, 0x36, 0x36,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+	  0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+	  0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+	  0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+	  0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+	  },
+	 },
+	{			/*  mode#7: 800 x 600  32Bpp  60Hz */
+	 800, 600, 32, 60,
+	 /*  Init_MISC */
+	 0x2B,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xFF, 0xBE, 0xEE, 0xFF, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x34, 0x03, 0x20, 0x09, 0xC0, 0x24, 0x24, 0x24,
+	  0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x38, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x24, 0x24, 0x24,
+	  0x04, 0x48, 0x83, 0x63, 0x68, 0x72, 0x57, 0x58,
+	  0x04, 0x55, 0x59, 0x24, 0x24, 0x00, 0x00, 0x24,
+	  0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x1C, 0x85, 0x35, 0x13,
+	  0x02, 0x45, 0x30, 0x35, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0x00, 0x00, 0x00, 0x6F, 0x7F, 0x7F, 0xFF, 0x24,
+	  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x24, 0x24,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xED, 0xED, 0xED,
+	  0x7B, 0xFF, 0xFF, 0xFF, 0xBF, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0x7F, 0x63, 0x63, 0x00, 0x68, 0x18, 0x72, 0xF0,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x58, 0x0C, 0x57, 0x64, 0x40, 0x57, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xE7, 0xBF, 0xFD,
+	  0x7F, 0x63, 0x00, 0x69, 0x18, 0x72, 0x57, 0x00,
+	  0x58, 0x0C, 0xE0, 0x20, 0x63, 0x57,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x56, 0x4B, 0x5E, 0x55, 0x86, 0x9D, 0x8E, 0xAA,
+	  0xDB, 0x2A, 0xDF, 0x33, 0x00, 0x00, 0x18, 0x00,
+	  0x20, 0x1F, 0x1A, 0x19, 0x0F, 0x0F, 0x0F, 0x00,
+	  },
+	 },
+	/* We use 1024x768 table to light 1024x600 panel for lemote */
+	{			/*  mode#4: 1024 x 600  16Bpp  60Hz  */
+	 1024, 600, 16, 60,
+	 /*  Init_MISC */
+	 0xEB,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x00, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xC8, 0x40, 0x14, 0x60, 0x00, 0x0A, 0x17, 0x20,
+	  0x51, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x00, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x22, 0x03, 0x24, 0x09, 0xC0, 0x22, 0x22, 0x22,
+	  0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x22, 0x22, 0x22,
+	  0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+	  0x00, 0x60, 0x59, 0x22, 0x22, 0x00, 0x00, 0x22,
+	  0x01, 0x80, 0x7A, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x16, 0x02, 0x0D, 0x82, 0x09, 0x02,
+	  0x04, 0x45, 0x3F, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+	  0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+	  0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+	  0xA3, 0x7F, 0x00, 0x82, 0x0b, 0x6f, 0x57, 0x00,
+	  0x5c, 0x0f, 0xE0, 0xe0, 0x7F, 0x57,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+	  0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+	  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+	  },
+	 },
+	{			/*  mode#5: 1024 x 768  24Bpp  60Hz */
+	 1024, 768, 24, 60,
+	 /*  Init_MISC */
+	 0xEB,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x30, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+	  0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+	  0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+	  0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x3B, 0x0D, 0x09, 0x02,
+	  0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+	  0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+	  0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+	  0xA3, 0x7F, 0x00, 0x86, 0x15, 0x24, 0xFF, 0x00,
+	  0x01, 0x07, 0xE5, 0x20, 0x7F, 0xFF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+	  0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+	  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+	  },
+	 },
+	{			/*  mode#4: 1024 x 768  32Bpp  60Hz */
+	 1024, 768, 32, 60,
+	 /*  Init_MISC */
+	 0xEB,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x32, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+	  0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+	  0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+	  0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x3B, 0x0D, 0x09, 0x02,
+	  0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+	  0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+	  0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+	  0x00, 0x00, 0x00, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+	  0xA3, 0x7F, 0x00, 0x86, 0x15, 0x24, 0xFF, 0x00,
+	  0x01, 0x07, 0xE5, 0x20, 0x7F, 0xFF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+	  0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+	  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+	  },
+	 },
+	{			/*  mode#6: 320 x 240  16Bpp  60Hz */
+	 320, 240, 16, 60,
+	 /*  Init_MISC */
+	 0xEB,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x32, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+	  0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+	  0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+	  0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x08, 0x43, 0x08, 0x43,
+	  0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+	  0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+	  0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+	  0x00, 0x00, 0x30, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+	  0x2E, 0x27, 0x00, 0x2b, 0x0c, 0x0F, 0xEF, 0x00,
+	  0xFe, 0x0f, 0x01, 0xC0, 0x27, 0xEF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+	  0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+	  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+	  },
+	 },
+
+	{			/*  mode#8: 320 x 240  32Bpp  60Hz */
+	 320, 240, 32, 60,
+	 /*  Init_MISC */
+	 0xEB,
+	 {			/*  Init_SR0_SR4 */
+	  0x03, 0x01, 0x0F, 0x03, 0x0E,
+	  },
+	 {			/*  Init_SR10_SR24 */
+	  0xF3, 0xB6, 0xC0, 0xDD, 0x00, 0x0E, 0x17, 0x2C,
+	  0x99, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0xC4, 0x32, 0x02, 0x01, 0x01,
+	  },
+	 {			/*  Init_SR30_SR75 */
+	  0x38, 0x03, 0x20, 0x09, 0xC0, 0x3A, 0x3A, 0x3A,
+	  0x3A, 0x3A, 0x3A, 0x3A, 0x00, 0x00, 0x03, 0xFF,
+	  0x00, 0xFC, 0x00, 0x00, 0x20, 0x18, 0x00, 0xFC,
+	  0x20, 0x0C, 0x44, 0x20, 0x00, 0x00, 0x00, 0x3A,
+	  0x06, 0x68, 0xA7, 0x7F, 0x83, 0x24, 0xFF, 0x03,
+	  0x00, 0x60, 0x59, 0x3A, 0x3A, 0x00, 0x00, 0x3A,
+	  0x01, 0x80, 0x7E, 0x1A, 0x1A, 0x00, 0x00, 0x00,
+	  0x50, 0x03, 0x74, 0x14, 0x08, 0x43, 0x08, 0x43,
+	  0x04, 0x45, 0x30, 0x30, 0x40, 0x20,
+	  },
+	 {			/*  Init_SR80_SR93 */
+	  0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x3A,
+	  0xF7, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x3A, 0x3A,
+	  0x00, 0x00, 0x00, 0x00,
+	  },
+	 {			/*  Init_SRA0_SRAF */
+	  0x00, 0xFB, 0x9F, 0x01, 0x00, 0xED, 0xED, 0xED,
+	  0x7B, 0xFB, 0xFF, 0xFF, 0x97, 0xEF, 0xBF, 0xDF,
+	  },
+	 {			/*  Init_GR00_GR08 */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
+	  0xFF,
+	  },
+	 {			/*  Init_AR00_AR14 */
+	  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+	  0x41, 0x00, 0x0F, 0x00, 0x00,
+	  },
+	 {			/*  Init_CR00_CR18 */
+	  0xA3, 0x7F, 0x7F, 0x00, 0x85, 0x16, 0x24, 0xF5,
+	  0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	  0x03, 0x09, 0xFF, 0x80, 0x40, 0xFF, 0x00, 0xE3,
+	  0xFF,
+	  },
+	 {			/*  Init_CR30_CR4D */
+	  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0x20,
+	  0x00, 0x00, 0x30, 0x40, 0x00, 0xFF, 0xBF, 0xFF,
+	  0x2E, 0x27, 0x00, 0x2b, 0x0c, 0x0F, 0xEF, 0x00,
+	  0xFe, 0x0f, 0x01, 0xC0, 0x27, 0xEF,
+	  },
+	 {			/*  Init_CR90_CRA7 */
+	  0x55, 0xD9, 0x5D, 0xE1, 0x86, 0x1B, 0x8E, 0x26,
+	  0xDA, 0x8D, 0xDE, 0x94, 0x00, 0x00, 0x18, 0x00,
+	  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x15, 0x03,
+	  },
+	 },
+};
+
+#define numVGAModes		ARRAY_SIZE(VGAMode)
-- 
2.4.4

